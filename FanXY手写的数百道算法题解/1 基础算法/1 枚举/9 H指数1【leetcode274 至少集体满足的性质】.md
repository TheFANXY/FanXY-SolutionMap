# H指数1【leetcode274 至少集体满足的性质】

## [我的网站=> 分享了我关于前后端的各种知识和生活美食~](https://www.fanxy.cloud)

## [我于Acwing平台分享的零散刷的各种各样的题](https://www.acwing.com/blog/content/33005/) 

给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。

根据维基百科上 [h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：`h` 代表“高引用次数” ，一名科研人员的 `h` **指数** 是指他（她）至少发表了 `h` 篇论文，并且 **至少** 有 `h` 篇论文被引用次数大于等于 `h` 。如果 `h` 有多种可能的值，**`h` 指数** 是其中最大的那个。

 

**示例 1：**

```
输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
```

**示例 2：**

```
输入：citations = [1,3,1]
输出：1
```

 

**提示：**

- `n == citations.length`
- `1 <= n <= 5000`
- `0 <= citations[i] <= 1000`



正常想法 =》 从最大的数字开始找，是否有大于等于数字相同订阅数量的论文 直到找到符合的。

这里的思想，其实潜在的利用到了排序的思想，但是还是数出来的，**其实不需要数，就满足一个性质。当排序之后，假设从小到大排序，如果 `a[i] >= x` 其实  `[i, n - 1]` 这个区间的都满足大于 `x`，即 `n - i` 个论文，都大于 `x`，那么就直接进行递减去找就行了。找最大的第一次满足数量大于`h指数的情况`** 

这里再深入思考一下，是否有必要用最多订阅数量？

极端一点，其实如果最多订阅是 1000000，但是其实只有 3 篇，从 1000000 数明显没什么意义。所以显然应该使用的是 `最多篇数` 递减去找。

```java
class Solution {
    public int hIndex(int[] c) {
        int n = c.length;
        Arrays.sort(c);
        for (int h = n; h > 0; h --) {
            if (c[n - h] >= h) return h;
        }
        return 0;
    }
}
```

