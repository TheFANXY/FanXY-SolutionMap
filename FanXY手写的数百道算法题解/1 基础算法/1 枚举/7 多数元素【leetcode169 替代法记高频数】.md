# <font color="bb000">多数元素【leetcode169 替代法记高频数】</font>

## [我的网站=> 分享了我关于前后端的各种知识和生活美食~](https://www.fanxy.cloud)

## [我于Acwing平台分享的零散刷的各种各样的题](https://www.acwing.com/blog/content/33005/) 

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**

```
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 5 * 10^4`
- `-10^9 <= nums[i] <= 10^9`

 

**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。



这里有一个精妙的做法，最多的数字比一半还多，意味着可以用到一种思想，摩尔选举。

具体而言就是 每当统计一个数字，如果下一个还是他，则计数 `加一`，如果下一个不是他，则计数 `减一`。如果 `减一` 后计数为0，意味着当前计数已经被其他数字给抵消完了，则从0开始统计下一个数字。

**为什么这样最后留下的是出现次数大于一半的数字？**

最恶劣的情况即：先拿到全部的答案数字，然后拿到所有其他数字，此时仍能求解成功。

那么其他情况下，别的数字互相消耗，则我们更能最终拿到答案数字。

```java
class Solution {
    public int majorityElement(int[] nums) {
        if (nums.length == 0) return 0;
        int t = nums[0];
        int cnt = 0;
        for (int i = 0; i < nums.length; i ++) {
            if (nums[i] == t) cnt ++;
            else if (nums[i] != t && cnt == 0) {
                t = nums[i]; 
            }
            else cnt --;
        }
        return t;
    }
}
```









