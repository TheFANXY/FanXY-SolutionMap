# <font color="bb000">第 k 个排列【leetcode60 模拟排列】</font>

## [我的网站=> 分享了我关于前后端的各种知识和生活美食~](https://www.fanxy.cloud)

## [我于Acwing平台分享的零散刷的各种各样的题](https://www.acwing.com/blog/content/33005/) 

**困难**

给出集合 `[1,2,3,...,n]`，其所有元素共有 `n!` 种排列。

按大小顺序列出所有排列情况，并一一标记，当 `n = 3` 时, 所有排列如下：

1. `"123"`
2. `"132"`
3. `"213"`
4. `"231"`
5. `"312"`
6. `"321"`

给定 `n` 和 `k`，返回第 `k` 个排列。

 

**示例 1：**

```
输入：n = 3, k = 3
输出："213"
```

**示例 2：**

```
输入：n = 4, k = 9
输出："2314"
```

**示例 3：**

```
输入：n = 3, k = 1
输出："123"
```

 

**提示：**

- `1 <= n <= 9`
- `1 <= k <= n!`



###  解析

排列的题型，大多数都是使用 `dfs` ，但是求第几个排列，很容易联想到 `leetcode31` 下一个排列，它利用的思想是，二分结合全排列性质，倒序寻找第一个出现不满足正向倒序的第一个数，然后从这个数后面的数二分找一个比它大的数【不能相等，然后进行交换，然后后面的数进行从大到小排列】。

虽然都是在求有次序的排列，但是本题显然求一个规定的次序，无法借鉴这题。

这题我们从最朴素的枚举思想看 => dfs => 排列类型题为了锁定答案，一般规定字典序排列。

从高位进行枚举，如果第一位选择 1 => 此时，若有 n 位的情况下，应一共有 `(n - 1)!` 的排列个数，此时如果求的 第 k 个排列的个数大于这个数字，显然，我们应该让第一位枚举下一个数 2。

从这个思想来看，我们的 `k` 减去 `(n - 1)!` 的个数。

求第一位选择 2 => 此时仍是 `(n - 1)!` 的排列数，进一步求已经减去过 `(n - 1)!` 新的 `k` 序号是否满足。

以此类推，那么我们就假设枚举的位数为 `i` ，此时选择一个数在这位，显然应有 `(n - 1 - i)!`  种可能。

当出现 `k <= (n - 1 - i)!` 的情况下，说明这位选择的情况下，能覆盖选 第 `k` 位 的排列，让 `i` 位锁定这个数字，然后去判断 `i + 1` 位的数字该选什么数字。

```java
举例 n = 3, k = 5 的情况下有如下排列。
1. 1 2 3
2. 1 3 2
3. 2 1 3
4. 2 3 1
5. 3 1 2
6. 3 2 1
```

按如上枚举方式推演。

> 1. 先枚举第一位 选择 1 的情况下，有 2! = 2 种排列 显然此时无法找到 k = 5 的情况， 更新 k => k -= 2! = 5 - 2 = 3 
>
> 2. 固枚举第一位 选择 2 的情况， 有 2! = 2 种排列 显然此时带上 上一次的排列个数 为 4，还是没法找到 第5个排列
>    本轮结束进行 k 的减去这轮即 k = k - 2 = 1
>    
>
> 3.然后枚举第一位 选择 3 的情况，，此时仍然是 2! = 2 种排列
> 此时 k == 1 < 2
> 可以选到固这位选择 3
>
> 4. 然后枚举下一位， 从小到大看，选择 1 的情况下， 有 1 种排列个数 ，此时 k == 1，固命中 选取这位 然后 k -= 1! = 0
> 5. 此时枚举最后一位，前面两个数字已经用了，只能用 2 且 k == 0 找到， 结束推演



```java
class Solution {
    public String getPermutation(int n, int k) {
        int [] f = new int [n + 1];
        boolean [] st = new boolean[n + 1];
        f[0] = 1;
        // f[i] = i! 阶乘
        for (int i = 1; i <= n; i ++) f[i] = f[i - 1] * i;
        
        // 答案
        StringBuilder ans = new StringBuilder("");

        // 枚举 第 i 位
        for (int i = 0; i < n; i ++) {
            // 枚举 第 i 位 填哪个数 => j + 1
            for (int j = 0; j < n; j ++) {
                // 已锁定的数直接跳过
                if (st[j]) continue;
                if (k <= f[n - 1 - i]) {
                    st[j] = true;
                    // 字符从 1 开始 固 append + 1 后的字符
                    ans.append(j+1);
                    break;
                } 
                // 此时 k > f[n - 1 - i] 不满足目前的排列个数
                // k 减去已经凑了的个数 然后进入下一轮循环 枚举自增的j
                k -= f[n - 1 - i];
            }
        } 
        // 返回字符串答案
        return ans.toString();
    }
}
```

