# <font color='red'>最低通行费【模板题】</font>

## [我的网站=> 分享了我关于前后端的各种知识和生活美食~](https://www.fanxy.cloud)

## [我于Acwing平台分享的零散刷的各种各样的题](https://www.acwing.com/blog/content/33005/) 

一个商人穿过一个 N × N 的正方形的网格，去参加一个非常重要的商务活动。

他要从网格的左上角进，右下角出。

每穿越中间 1 个小方格，都要花费 1 个单位时间。

商人必须在 (2N−1) 个单位时间穿越出去。

而在经过中间的每个小方格时，都需要缴纳一定的费用。

这个商人期望在规定时间内用最少费用穿越出去。

请问至少需要多少费用？

注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。

#### 输入格式

第一行是一个整数，表示正方形的宽度 N。

后面 N 行，每行 N 个不大于 100 的正整数，为网格上每个小方格的费用。

#### 输出格式

输出一个整数，表示至少需要的费用。

#### 数据范围

1≤N≤100

#### 输入样例：

```
5
1  4  6  8  10
2  5  7  15 17
6  8  9  18 20
10 11 12 19 21
20 23 25 29 33
```

#### 输出样例：

```
109
```

#### 样例解释

样例中，最小值为 109=1+2+5+7+9+12+19+21+33



### 解析

题目一眼数字三角形模型，这里必须在 `2N - 1` 的时间穿越过去。

本题看似是一个非常复杂的问题，因为如果出现了可以回头的情况，就无法用正常的动态规划去逐层分解，但是题目有一个关键信息，走过的方块数不能超过 **`2n - 1`** 个格子，这里我们仔细思考，在一个网格图中，衡量两点的距离的尺度

就不是坐标系尺度下的欧几里得距离，而是曼哈顿距离，对于（1，1）到（n，n）的曼哈顿距离，显然应该是n - 1 + n - 1 = 2n - 2,而我们的起始点是在区域外，走到`（1，1）`这一步也是算在距离内。

因此本题隐含一个条件——》 每步必须往右或者下走，不然就不符合条件。

这样这个复杂的模型就被简化成了数字三角形模型，只不过和采花生不同，状态表示的属性没有变化，而状态表示的集合是维护最小值，因此我们需要对边界点`i = 0`以及`j = 0`的地方初始化无穷远，**然后为了让`f【1】【1】 = g【1】【1】`，还需要把它前一步规划的点进行提前赋值。**

```java
import java.io.*;
import java.util.*;

public class Main {
    
    static int N = 110, n, max = 0x3f3f3f3f;
    static int [][] a = new int [N][N];
    static int [][] f = new int [N][N];
    static Scanner sc = new Scanner(System.in);
    
    public static void main(String [] args) {
        n = sc.nextInt();
        for (int i = 0; i <= n; i ++) Arrays.fill(f[i], max);
        f[0][1] = 0;
        
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= n; j ++) {
                a[i][j] = sc.nextInt();
                f[i][j] = Math.min(f[i-1][j], f[i][j-1]) + a[i][j];
            }
        }
        System.out.println(f[n][n]);
    }
}
```







