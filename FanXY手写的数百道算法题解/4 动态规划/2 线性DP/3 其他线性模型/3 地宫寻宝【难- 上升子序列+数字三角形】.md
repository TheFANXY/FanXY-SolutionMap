# <font color='red'>地宫寻宝【难- 上升子序列+数字三角形】</font>

## [我的网站=> 分享了我关于前后端的各种知识和生活美食~](https://www.fanxy.cloud)

## [我于Acwing平台分享的零散刷的各种各样的题](https://www.acwing.com/blog/content/33005/) 

X 国王有一个地宫宝库，是 n×m 个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。

地宫的入口在左上角，出口在右下角。

小明被带到地宫的入口，国王要求他只能向右或向下行走。

走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。

当小明走到出口时，如果他手中的宝贝恰好是 k 件，则这些宝贝就可以送给小明。

请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 k 件宝贝。



**输入格式**

第一行 33 个整数，n,m,k，含义见题目描述。

接下来 n 行，每行有 m 个整数 Ci 用来描述宝库矩阵每个格子的宝贝价值。



**输出格式**

输出一个整数，表示正好取 k 个宝贝的行动方案数。

该数字可能很大，输出它对 1000000007 取模的结果。



**数据范围**

1 ≤ n, m ≤ 50
1 ≤ k ≤ 12
0 ≤ Ci ≤ 12



**输入样例1：**

```
2 2 2
1 2
2 1
```

**输出样例1：**

```
2
```

**输入样例2：**

```
2 3 2
1 2 3
2 1 5
```

**输出样例2：**

```
14
```



### 解析

闫式 `DP` 分析法

我们为了满足最长上升子序列的思路，需要划分下一步的选取价值，大于上一步。

为了满足数字三角形模型，需要满足每一步的状态来自于从上，或者从左走到当前步。

故综合两个条件进行 DP 划分，同时还有一个数量限制。

因此，设置状态方程为 `f[i][j][u][v]`

表示，到达 `(i, j)` 位置， 且选取了 `u` 个物品，第 `u` 个物品的价值为 `v` 。【注意，这里不代表 `(i,j)` 位置的物品价值为 `v` 】

因此可以划分为以下几种可能 ====> 



1. 不选 `(i, j)` 位置的物品 : `f[i-1][j][u][v]` 和 `f[i][j-1][u][v]`

2. 选择 `(i, j)` 位置的物品 【N 种可能，一旦选取需要枚举 `u-1`(因此需要满足 `u > 0`) 个物品，且这些物品的价值最大都小于 `w[i][j]` 的情况】

   即  `f[i-1][j][u-1][v']` 和 `f[i][j-1][u-1][v']`。

   其中 需要枚举所有满足 `v' < v` 的情况。

3. 综上，需要开四重循环，枚举所有情况，并多开一重循环，枚举满足的 `v'`，其次这道题因为有限制：物品价值的取值范围是 `0 ~ 12`，为了区分不选和选了价值为 `0` 的物品，可以把每个物品的价值都 `+1` ，把范围扩大为 `1 ~ 13`，用 `0` 代表不选择第一个点时的价值，因为数组最小为 `0`，不能用 `-1` 代表不选，所以才进行的以上操作。



因为是计算数量，就需要累加上面所说的所有情况，并记得 `% MOD` 【题目要求】

```java
import java.io.*;

public class Main {
    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    static int N = 55, n, m, k, mod = (int) 1e9 + 7;
    static int w[][] = new int[N][N]; //每个物品的价值
    static int f[][][][] = new int[N][N][13][14];
    /**
     * 因为物品价值的取值范围是0 ~ 12，但是我们我们需要初始化第一个点[1][1],
     * 如果我们不要第一点的时候，我们记录价值时应该要取负数，但因为数组不能有负的下标，
     * 所以我们把每个物品的价值都+1 ，把范围扩大为 1 ~ 13，用0代表不选择第一个点时的价值。
     */
    public static void main(String[] args)throws IOException {
        String s1[] = in.readLine().split(" ");
        n = Integer.parseInt(s1[0]);
        m = Integer.parseInt(s1[1]);
        k = Integer.parseInt(s1[2]);

        for (int i = 1; i <= n; i++) {
            String s2 [] = in.readLine().split(" ");
            // 加一的原因见上
            for (int j = 1; j <= m; j++)
                w[i][j] = Integer.parseInt(s2[j-1]) + 1;
        }
        f[1][1][1][w[1][1]] = 1;//选择第一个物品
        f[1][1][0][0] = 1;//不选第一个物品

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m ; j++) {
                if (i == 1 && j == 1) continue;
                //虽然题目k的范围是1 ~ k，但是我们这里遍历的是取多少个物品
                //所以存在我们可以不取任何物品的情况，故要从1开始
                for (int u = 0; u <= k; u++) {
                    //枚举最后一件物品的价值c  0也是一个合法取值，表示“当前没有取任何物品”
                    for (int v = 0; v <= 13; v++) {
                        int val = f[i][j][u][v];
                        val = (val + f[i-1][j][u][v]) % mod;
                        val = (val + f[i][j-1][u][v]) % mod;
                        if (u > 0 && v == w[i][j]){
                            //因为要取，所以u>0，即个数>0。v==w[i][j]是因为取完之后是c
                            for (int c = 0; c < v; c++) {
                                val = (val + f[i-1][j][u-1][c]) % mod;
                                val = (val + f[i][j-1][u-1][c]) % mod;
                            }
                        }
                        f[i][j][u][v] = val;
                    }
                }
            }
        }
        //由题意，n m k固定，所以只根据价值循环一遍，把方案数加起来就可以。
        //f[n][m][k][0]表示什么物品都没拿，它的值是0，所以从1开始循环和从0开始循环是不影响结果的。
        int ans = 0;
        for (int i = 0; i <= 13; i++) {
            ans = (ans + f[n][m][k][i]) % mod;
        }
        System.out.println(ans);
    }
}
```

