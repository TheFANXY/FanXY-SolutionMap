# $$\color{Red}{股票问题3【leetcode123 限制交易次数】}$$

## [我的网站=> 分享了我关于前后端的各种知识和生活美食~](https://www.fanxy.cloud)

## [我于Acwing平台分享的零散刷的各种各样的题](https://www.acwing.com/blog/content/33005/) 

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

 

**提示：**

- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^5`



### 解析

这里首先要明确，**一次买入卖出合为一笔交易（题目规定），同时我们每次买入前必须卖出当前持有的所有股票。**
我们以状态机模型来规定 **`f[i][j][k]`** 代表，正在进行第 **`j`** 次交易，且到达第 **`i`** 天，而 **`k`** 的 **`0或1`** 表示当前是否持有股票。
那么就有两种状态， **即k为0的无股票状态，和k为1的持有股票状态**；
状态转移可以有如下情况：
**`购入 0 - > 1`**     **`f[i][j][1] = f[i-1][j-1][0] - w[i]`**
**`持仓 1 - > 1`**     **`f[i][j][1] = f[i-1][j][1]`**
**`零仓 0 - > 0`**     **`f[i][j][0] = f[i-1][j][0]`**
**`卖空 1 - > 0`**     **`f[i][j][0] = f[i-1][j][1] + w[i]`**

根据题意，也就是想要完成一次新交易的开始**`（即从j-1到达j）`**需要由**`f[i-1][j-1][0] - w[i]`**进行转移才能达成**`j`**的增加。其他情况的状态转移都是还处于**`j-1`**交易状态。

这个做法能推广到 `k` 次限制交易的情况，而题目要求 `2` 次，弱化了，所以三维数组没有超时。

但是仍推荐滚动数组优化，即类似01背包问题的倒序优化。可以将时间从 `70ms` 优化到 **个位数**。



#### 三维数组状态机

```java
class Solution {
    public int maxProfit(int[] prices) {
        int [][][] f = new int [prices.length + 2][3][2];
        for (int i = 0; i <= prices.length; i ++) 
            for (int j = 0; j < 3; j ++)
                Arrays.fill(f[i][j], -0x3f3f3f3f);
        // 初始化所有天数未持有股票为0 因为没有买股票
        for (int i = 0; i <= prices.length; i ++) f[i][0][0] = 0;

        // 状态机状态计算
        for (int i = 1; i <= prices.length; i ++)
            for (int j = 1; j <= 2; j ++) {
                f[i][j][0] = Math.max(f[i - 1][j][0], f[i - 1][j][1] + prices[i - 1]);
                f[i][j][1] = Math.max(f[i - 1][j][1], f[i - 1][j - 1][0] - prices[i - 1]);
            }
        int res = 0;
        for (int i = 0; i <= 2; i ++) res = Math.max(res, f[prices.length][i][0]);
        return res;
    }
}
```



#### 滚动数组优化

```java
class Solution {
    public int maxProfit(int[] prices) {
        int [][] f = new int [3][2];
        for (int i = 0; i < 3; i ++) Arrays.fill(f[i], -0x3f3f3f3f);
        // 初始化所有天数未持有股票为0 因为没有买股票
        f[0][0] = 0;

        // 状态机状态计算
        for (int i = 1; i <= prices.length; i ++)
            for (int j = 2; j >= 1; j --) {
                f[j][0] = Math.max(f[j][0], f[j][1] + prices[i - 1]);
                f[j][1] = Math.max(f[j][1], f[j - 1][0] - prices[i - 1]);
            }
        int res = 0;
        for (int i = 0; i <= 2; i ++) res = Math.max(res, f[i][0]);
        return res;
    }
}
```

