# <font color='bb000'>通配符匹配【leetcode44 通配符DP】</font>

## [我的网站=> 分享了我关于前后端的各种知识和生活美食~](https://www.fanxy.cloud)

## [我于Acwing平台分享的零散刷的各种各样的题](https://www.acwing.com/blog/content/33005/) 



给你一个输入字符串 (`s`) 和一个字符模式 (`p`) ，请你实现一个支持 `'?'` 和 `'*'` 匹配规则的通配符匹配：

- `'?'` 可以匹配任何单个字符。
- `'*'` 可以匹配任意字符序列（包括空字符序列）。

判定匹配成功的充要条件是：字符模式必须能够 **完全匹配** 输入字符串（而不是部分匹配）。

 

**示例 1：**

```
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

**示例 2：**

```
输入：s = "aa", p = "*"
输出：true
解释：'*' 可以匹配任意字符串。
```

**示例 3：**

```
输入：s = "cb", p = "?a"
输出：false
解释：'?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```

 

**提示：**

- `0 <= s.length, p.length <= 2000`
- `s` 仅由小写英文字母组成
- `p` 仅由小写英文字母、`'?'` 或 `'*'` 组成



### 解析

这道题看上去要比之前的第十题，【正则匹配】更简单，因为之前必须匹配 `*` 前面的字符，而这道题可以直接匹配任意长度字符。

从集合的角度来思考问题，用一个可以递推的公式，表示一种状态，能从一种状态不断迭代，表示更新的状态。

我们这里考虑 `f[i][j]` 表示从模板串 `s` 的前 `i` 个字符，和通配串 `p` 的前 `j` 个字符进行匹配，表示状态为能否转移而来。

那么我们需要考虑集合划分的方式，我们可以考虑 `s[j]` 是否为 `*` 作为划分的条件。



### 为什么？

首先， `s[i]` 只能等于相同字符，或者 `*` 或 `?`，而 `?` 可以看作任意的一个字符，我们可以把 `?` 的情况纳入字符匹配的或逻辑运算符号，而如果是 `*` 的情况，和之前的那道题不同，不需要考虑特别多，只需要考虑 `*` 匹配了 `s串` 多少位，可以匹配 `[0 -> n]` 位。



### `p[j] == *` 该如何考虑？

我们不需要考虑类似正则的 `*` 前面的符号是什么，只需要考虑可以匹配 `[0 -> n]` 位的情况下，是否能匹配成功。

```java
            匹配 0 个       匹配 1 个      匹配 2 个                
f[i][j] =   f[i][j-1]  || f[i-1][j-1] || f[i-2][j-1] || ......   
```



### 那此时需要 `O(n ^ 3)` 时间复杂度，如何优化？

考虑到此时类似完全背包模型，可以考虑到能容纳的极限个即满足 全部字符均匹配的情况。

那么我们考虑上一层状态是否可以联系本层。

```java
与下面的当前层对比可发现，相当于少了一个 【或运算】 f[i][j-1] 的项         
            匹配 0 个       匹配 1 个      匹配 2 个                
f[i][j] =   f[i][j-1]  || f[i-1][j-1] || f[i-2][j-1] || ......   
                
                           匹配 0 个       匹配 1 个      匹配 2 个   
f[i-1][j] =               f[i-1][j-1] || f[i-2][j-1] || f[i-3][j-1] || .....   
```



即直接 `f[i][j] = f[i][j-1] || i != 0 && f[i-1][j] `

> <font color='red'>i从0开始就是针对`s=”aa”,p=”*”`这样的条件，靠`i=0`时把`f[0][1]`设为true，使其符合题意。</font>

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int n = s.length(), m = p.length();
        boolean [][] f = new boolean[n+3][m+3];
        s = " " + s;
        p = " " + p;
        f[0][0] = true;

        for (int i = 0; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (p.charAt(j) != '*') {
                    boolean flag = (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?');
                    f[i][j] = i != 0 && f[i-1][j-1] && flag;
                } else {
                    f[i][j] = f[i][j-1] || (i != 0 && f[i-1][j]);
                }
            }
        }
        return f[n][m];
    }
}
```

